<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>RiderLink • Rider Card MVP</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
  html, body { height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background:#0b0c10; color:#e5e7eb; }
  #map { height:100%; width:100%; }

  /* Rider Card button */
  .fab { position:fixed; top:10px; right:10px; z-index:900; background:#15171c; border:1px solid #1f2937; color:#e5e7eb; padding:8px 12px; border-radius:10px; cursor:pointer; display:flex; gap:8px; align-items:center; }
  .fab:hover { background:#1a1f2b; }
  /* Shift left when chat is open so it never overlaps the chat close button */
  .fab.shifted { right: calc(10px + 420px); }
  @media (max-width: 640px) {
    .fab.shifted { right: calc(10px + 92vw); }
  }

  /* Rider Card modal */
  .modal { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,.55); z-index:1000; }
  .card { width:min(600px, 94vw); background:#15171c; border:1px solid #1f2937; border-radius:14px; box-shadow:0 20px 60px rgba(0,0,0,.45); }
  .card header { padding:14px 16px; border-bottom:1px solid #1f2937; font-weight:800; display:flex; align-items:center; justify-content:space-between; }
  .card main { padding:16px; }
  .row { display:flex; gap:10px; margin:10px 0; flex-wrap:wrap; align-items:center; }
  .label { width:100px; color:#9ca3af; font-size:14px; }
  .inp, select { flex:1; min-width:160px; background:#0e1117; color:#e5e7eb; border:1px solid #232937; border-radius:8px; padding:10px 12px; }
  .hint { color:#9ca3af; font-size:12px; }
  .btn { border:1px solid #2a2f3b; background:#1f2430; color:#fff; padding:10px 14px; border-radius:10px; cursor:pointer; }
  .btn.primary { background:#22c55e; border-color:#22c55e; color:#052914; font-weight:800; }
  .btn.ghost { background:transparent; }
  .footer { display:flex; justify-content:flex-end; gap:10px; padding:12px 16px; border-top:1px solid #1f2937; }

  /* Toast */
  .toast { position:fixed; left:50%; transform:translateX(-50%); top:12px; background:#15171c; border:1px solid #1f2937; color:#e5e7eb; padding:10px 14px; border-radius:10px; z-index:999; display:none; }

  /* Status bubbles: glossy pill with emoji + text */
  .bubble {
    pointer-events:auto;
    background:linear-gradient(180deg,#ffffff,#f1f5f9);
    color:#0b1220;
    border:1px solid #0b1220;
    border-radius:999px;
    padding:6px 10px;
    font-weight:800;
    font-size:12px;
    box-shadow:0 6px 20px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.6);
    white-space:nowrap;
    display:inline-flex;
    align-items:center;
    gap:6px;
  }
  .bubble .emoji { font-size:14px; }
  .bubble:hover { box-shadow:0 8px 28px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.7); transform:translateY(-1px); }
  .bubble:active { transform:translateY(0); }

  /* Tag labels */
  .tag { background:#111827; color:#e5e7eb; border:1px solid #374151; padding:2px 6px; border-radius:6px; font-size:11px; }

  /* Chat drawer */
  #chat { position:fixed; right:0; top:0; bottom:0; width:min(420px, 92vw); transform:translateX(100%); transition:transform .2s ease; background:#0e0e0e; color:#fff; z-index:800; display:flex; flex-direction:column; border-left:1px solid #222; }
  #chat.open { transform:translateX(0%); }
  #chatHead { padding:10px 12px; border-bottom:1px solid #222; display:flex; align-items:center; justify-content:space-between; }
  #chatBody { flex:1; overflow:auto; padding:12px; display:flex; flex-direction:column; gap:8px; }
  #chatFoot { display:flex; gap:8px; padding:12px; border-top:1px solid #222; }
  .msg { padding:8px 10px; border-radius:10px; max-width:80%; }
  .msg.me { background:#1b5e20; margin-left:auto; }
  .msg.them { background:#263238; margin-right:auto; }

  /* Popup tweaks */
  .leaflet-popup-content { margin:8px; }
  .muted { color:#9ca3af; font-size:13px; }

  /* Small top bar hint when picking pin */
  .pickbar { position:fixed; top:8px; left:50%; transform:translateX(-50%); background:#15171c; border:1px solid #1f2937; color:#e5e7eb; padding:6px 10px; border-radius:999px; z-index: 900; display:none; }
</style>
</head>
<body>
<div id="map"></div>

<!-- Rider Card button -->
<button id="riderCardBtn" class="fab">Rider Card</button>

<!-- Pick hint -->
<div class="pickbar" id="pickbar">Tap anywhere on the map to set your pin</div>

<!-- Rider Card modal -->
<div class="modal" id="riderModal" role="dialog" aria-modal="true" style="display:none">
  <div class="card">
    <header>
      <div>Rider Card</div>
      <button class="btn ghost" id="closeCard" title="Close">Close</button>
    </header>
    <main>
      <div class="row">
        <div class="label">Name</div>
        <input id="nameInp" class="inp" placeholder="Display name" />
      </div>
      <div class="row">
        <div class="label">Bike</div>
        <input id="bikeInp" class="inp" placeholder="e.g., MT-09, GSX-R, Tiger 900" />
      </div>
      <div class="row">
        <div class="label">Status</div>
        <select id="statusSel" class="inp">
          <option>Ready now</option>
          <option>Coffee</option>
          <option>Fuel stop</option>
          <option>Twisties</option>
          <option>Chill loop</option>
          <option>Rain check</option>
        </select>
      </div>

      <div class="row" style="margin-top:14px">
        <div class="label">Location</div>
        <div style="display:flex; flex-direction:column; gap:8px; flex:1">
          <label><input type="radio" name="locmode" value="live" checked> Live GPS</label>
          <div id="liveOptions" class="hint" style="margin-left:20px">
            Precision:
            <label style="margin-left:6px"><input type="radio" name="precision" value="approx" checked> Approx</label>
            <label style="margin-left:6px"><input type="radio" name="precision" value="exact"> Exact</label>
            <span class="hint" style="margin-left:8px">(Approx rounds to ~500 m grid)</span>
          </div>
          <label><input type="radio" name="locmode" value="pinned"> Pinned location</label>
          <div id="pinOptions" style="display:none; gap:8px; flex-wrap:wrap; margin-left:20px">
            <button class="btn" id="pinPick">Pick on map</button>
            <input type="number" step="any" id="pinLat" class="inp" placeholder="Lat">
            <input type="number" step="any" id="pinLng" class="inp" placeholder="Lng">
            <button class="btn" id="pinSave">Save pin</button>
          </div>
          <label><input type="radio" name="locmode" value="hidden"> Hidden</label>
          <div class="hint" style="margin-left:20px">You will not appear on the map.</div>
        </div>
      </div>
    </main>
    <div class="footer">
      <button class="btn primary" id="saveCard">Save</button>
    </div>
  </div>
</div>

<!-- Toast -->
<div class="toast" id="toast"></div>

<!-- Chat -->
<div id="chat">
  <div id="chatHead">
    <strong id="chatTitle"></strong>
    <button id="chatClose">Close</button>
  </div>
  <div id="chatBody"></div>
  <div id="chatFoot">
    <input id="chatInput" class="inp" placeholder="Type a message" style="flex:1">
    <button class="btn primary" id="chatSend">Send</button>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
/* Feature flags */
const USE_SUPABASE = false;

/* API stub - swap internals later when we connect Supabase */
const api = (() => {
  if (!USE_SUPABASE) {
    return {
      listRidersAround: async ({ lat, lng }) => {
        const rnd = mulberry32(Math.floor(lat*1e4) ^ Math.floor(lng*1e4));
        const statuses = [['Ready now','✅'],['Coffee','☕'],['Fuel stop','⛽'],['Twisties','🌀'],['Chill loop','🧭'],['Lunch','🍔'],['Rain check','🌧']];
        const bikes = ['ZX6R','MT-09','R7','GSX-S750','Panigale V2','CBR650R','Tiger 900','T7','Z900'];
        return Array.from({length:10}).map((_,i)=>({
          id:'r'+i,
          name:'Rider '+(i+1),
          lat: lat + (rnd()-0.5)*0.06,
          lng: lng + (rnd()-0.5)*0.06,
          status: statuses[Math.floor(rnd()*statuses.length)],
          bike: bikes[Math.floor(rnd()*bikes.length)]
        }));
      },
      sendMessage: async (toId, body) => {
        console.log('[fake sendMessage]', { toId, body });
        return { ok:true };
      },
      upsertPresence: async ({ lat, lng, precision }) => {
        console.log('[fake upsertPresence]', { lat, lng, precision });
        return { ok:true };
      }
    };
  }

  // placeholder for real Supabase wiring later
  return {
    listRidersAround: async ({ lat, lng }) => [],
    sendMessage: async (toId, body) => ({ ok:false }),
    upsertPresence: async ({ lat, lng, precision }) => ({ ok:false }),
  };
})();

/* State */
const state = {
  map: null,
  profile: { name: "", bike: "", status: "Ready now" },
  locMode: "live",          // live | pinned | hidden
  precision: "approx",      // approx | exact, for live
  pinned: null,             // {lat,lng}
  liveWatchId: null,
  anchor: null,             // lat/lng used to seed rider list (rounded in approx mode)
  youMarker: null,
  homeMarker: null,
  riderAnchors: new Map(),
  riderBubbles: new Map(),
  meetPins: [],
  pickingPin: false,
};

/* Utils */
function toast(msg, ms=1800){ const t=document.getElementById('toast'); t.textContent=msg; t.style.display='block'; setTimeout(()=>t.style.display='none', ms); }
function showPickbar(show){ document.getElementById('pickbar').style.display = show ? 'block' : 'none'; }
function esc(s){ return String(s).replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c])); }
function metersToDegLat(m){ return m/111320; }
function metersToDegLng(m, lat){ return m/(111320*Math.cos(lat * Math.PI/180) || 1); }
function roundApprox(lat,lng){ const dLat = metersToDegLat(500); const dLng = metersToDegLng(500, lat); const rLat = Math.round(lat/dLat)*dLat; const rLng = Math.round(lng/dLng)*dLng; return [ +rLat.toFixed(6), +rLng.toFixed(6) ]; }
function mulberry32(a){ return function(){ let t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; } }

/* Map */
function initMap(){
  state.map = L.map('map', { zoomControl:true });
  state.map.setView([20,0], 2); // safe initial view
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution:'&copy; OpenStreetMap' }).addTo(state.map);
}

/* Rider Card open/close */
function openCard(prefillOnly=false){
  document.getElementById('nameInp').value = state.profile.name || "";
  document.getElementById('bikeInp').value = state.profile.bike || "";
  document.getElementById('statusSel').value = state.profile.status || "Ready now";
  document.querySelectorAll('input[name="locmode"]').forEach(r => r.checked = (r.value === state.locMode));
  document.querySelectorAll('input[name="precision"]').forEach(r => r.checked = (r.value === state.precision));
  document.getElementById('pinLat').value = state.pinned?.lat ?? "";
  document.getElementById('pinLng').value = state.pinned?.lng ?? "";
  toggleLocOptions();
  if (!prefillOnly) {
    document.getElementById('riderModal').style.display = 'flex';
    setTimeout(()=> state.map.invalidateSize(), 50);
  }
}
function closeCard(){
  document.getElementById('riderModal').style.display = 'none';
  setTimeout(()=> state.map.invalidateSize(), 50);
}

/* Save Rider Card */
function saveCard(){
  state.profile.name = document.getElementById('nameInp').value.trim() || "Rider";
  state.profile.bike = document.getElementById('bikeInp').value.trim() || "Unknown";
  state.profile.status = document.getElementById('statusSel').value;
  state.locMode = document.querySelector('input[name="locmode"]:checked')?.value || "live";
  state.precision = document.querySelector('input[name="precision"]:checked')?.value || "approx";

  try {
    localStorage.setItem('profile', JSON.stringify(state.profile));
    localStorage.setItem('locMode', state.locMode);
    localStorage.setItem('precision', state.precision);
    if (state.pinned) localStorage.setItem('pinned', JSON.stringify(state.pinned));
  } catch {}

  applyLocationMode(true);
  closeCard();
}

/* Apply location mode */
function applyLocationMode(firstRun=false){
  if (state.liveWatchId != null) { navigator.geolocation.clearWatch(state.liveWatchId); state.liveWatchId = null; }
  if (state.youMarker) { try { state.map.removeLayer(state.youMarker); } catch {} state.youMarker = null; }
  if (state.homeMarker) { try { state.map.removeLayer(state.homeMarker); } catch {} state.homeMarker = null; }

  if (state.locMode === 'hidden') {
    state.anchor = null;
    clearRiders();
    toast('Hidden. You will not appear on the map.');
    return;
  }

  if (state.locMode === 'pinned') {
    if (!state.pinned) {
      toast('Pick or enter a pin location first.');
      openCard(true);
      return;
    }
    state.anchor = [state.pinned.lat, state.pinned.lng];
    drawYouAt(state.anchor, true);
    state.map.setView(state.anchor, 13);
    seedAndDrawRiders();
    return;
  }

  // live
  if (!navigator.geolocation) {
    toast('GPS not available. Switching to Pinned.');
    state.locMode = 'pinned';
    openCard(true);
    return;
  }
  toast('Sharing live location' + (state.precision === 'approx' ? ' (approx)' : ''));
  state.liveWatchId = navigator.geolocation.watchPosition(
    async pos => {
      let lat = pos.coords.latitude, lng = pos.coords.longitude;
      let anchor = [lat, lng];
      if (state.precision === 'approx') anchor = roundApprox(lat, lng);
      state.anchor = anchor;

      // show exact for your marker, anchor used for discovery
      drawYouAt([lat, lng], false);
      if (firstRun) state.map.setView(anchor, 13);

      await api.upsertPresence({ lat: anchor[0], lng: anchor[1], precision: state.precision });
      seedAndDrawRiders();
    },
    () => { toast('GPS failed. Try Pinned.'); },
    { enableHighAccuracy: false, maximumAge: 5000, timeout: 8000 }
  );
}

/* Draw "you" and optional Home tag */
function drawYouAt(latlng, showHome){
  if (state.youMarker) { try { state.map.removeLayer(state.youMarker); } catch {} }
  state.youMarker = L.circleMarker(latlng, { radius:8, color:'#60a5fa', weight:3, fillColor:'#60a5fa', fillOpacity:0.6 }).addTo(state.map);
  if (showHome) {
    const garageSVG = 'data:image/svg+xml;utf8,'+encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><g transform="translate(4,3)"><path d="M10 0 L20 6 L20 18 L0 18 L0 6 Z" fill="#111" stroke="#333"/><rect x="3" y="9" width="14" height="6" fill="#666"/><rect x="5" y="11" width="10" height="2" fill="#999"/></g></svg>`);
    const icon = L.icon({ iconUrl: garageSVG, iconSize:[28,28], iconAnchor:[14,24] });
    if (state.homeMarker) { try { state.map.removeLayer(state.homeMarker); } catch {} }
    state.homeMarker = L.marker(latlng, { icon }).addTo(state.map).bindTooltip('<span class="tag">Home</span>', { permanent:true, direction:'top', offset:[0,-14], opacity:1 });
  }
}

/* Riders via API */
async function seedAndDrawRiders(){
  if (!state.anchor) { clearRiders(); return; }
  const [lat,lng] = state.anchor;
  const riders = await api.listRidersAround({ lat, lng });
  drawRiders(riders);
}
function drawRiders(riders){
  clearRiders();
  riders.forEach(r => {
    const anchorMarker = L.marker([r.lat, r.lng], { opacity:0 }).addTo(state.map);
    const html = `
      <div>
        <h4 style="margin:0 0 6px 0">${esc(r.name)}</h4>
        <div class="muted">${esc(r.bike)} • ${esc(r.status[0])}</div>
        <div style="display:flex; gap:8px; margin-top:8px">
          <button class="btn" data-act="chat">Message</button>
          <button class="btn primary" data-act="meet">Meet here</button>
        </div>
      </div>`;
    anchorMarker.bindPopup(html);

    const bubble = L.marker([r.lat, r.lng], {
      icon: L.divIcon({ className:'', html:`<div class="bubble"><span class="emoji">${r.status[1]}</span><span>${esc(r.status[0])}</span></div>` })
    }).addTo(state.map);

    bubble.on('click', () => {
      anchorMarker.openPopup();
      setTimeout(() => {
        const root = anchorMarker.getPopup()?.getElement();
        if (!root) return;
        root.querySelector('[data-act="chat"]').onclick = () => openChat(r);
        root.querySelector('[data-act="meet"]').onclick = () => { openChat(r); dropMeetPin(r.lat, r.lng); addChatMsg('Meet here: pin dropped'); anchorMarker.closePopup(); };
      }, 0);
    });

    state.riderAnchors.set(r.id, anchorMarker);
    state.riderBubbles.set(r.id, bubble);
  });
}
function clearRiders(){
  for (const m of state.riderAnchors.values()) { try { state.map.removeLayer(m); } catch {} }
  for (const m of state.riderBubbles.values()) { try { state.map.removeLayer(m); } catch {} }
  state.riderAnchors.clear(); state.riderBubbles.clear();
}

function dropMeetPin(lat,lng){
  const pin = L.marker([lat,lng]).addTo(state.map).bindTooltip('<span class="tag">Meet</span>', {permanent:true, direction:'top', offset:[0,-12]});
  state.meetPins.push(pin);
  setTimeout(()=>{ try { state.map.removeLayer(pin); } catch{} }, 60000);
}

/* Chat with FAB shift */
function openChat(rider){
  const chat = document.getElementById('chat');
  chat.classList.add('open');
  document.getElementById('chatTitle').textContent = rider.name;
  document.getElementById('chatBody').innerHTML = '';
  addChatMsg(`Hey ${rider.name}, I am ${state.profile.name}.`, false);
  document.getElementById('riderCardBtn').classList.add('shifted');
}
function addChatMsg(text, me=true){
  const div = document.createElement('div');
  div.className = 'msg ' + (me ? 'me' : 'them');
  div.textContent = text;
  document.getElementById('chatBody').appendChild(div);
  document.getElementById('chatBody').scrollTop = 1e9;
}

/* Pin interactions inside Rider Card */
function toggleLocOptions(){
  const mode = document.querySelector('input[name="locmode"]:checked')?.value;
  document.getElementById('liveOptions').style.display = mode === 'live' ? 'block' : 'none';
  document.getElementById('pinOptions').style.display  = mode === 'pinned' ? 'flex'  : 'none';
}
function startPickPin(){
  document.getElementById('riderModal').style.display = 'none';
  showPickbar(true);
  state.pickingPin = true;
  const once = e => {
    if (!state.pickingPin) return;
    state.pickingPin = false;
    showPickbar(false);
    state.pinned = { lat:e.latlng.lat, lng:e.latlng.lng };
    openCard(); // reopen with values filled
  };
  state.map.once('click', once);
}

/* Restore from storage on boot */
function restore(){
  try {
    const p = JSON.parse(localStorage.getItem('profile') || 'null'); if (p) state.profile = p;
    const m = localStorage.getItem('locMode'); if (m) state.locMode = m;
    const pr = localStorage.getItem('precision'); if (pr) state.precision = pr;
    const pin = JSON.parse(localStorage.getItem('pinned') || 'null'); if (pin && Number.isFinite(pin.lat) && Number.isFinite(pin.lng)) state.pinned = pin;
  } catch {}
}

/* UI wiring */
document.getElementById('riderCardBtn').onclick = () => openCard();
document.getElementById('closeCard').onclick = () => closeCard();
document.getElementById('saveCard').onclick = () => saveCard();
document.getElementById('chatClose').onclick = () => {
  document.getElementById('chat').classList.remove('open');
  document.getElementById('riderCardBtn').classList.remove('shifted');
};
document.getElementById('chatSend').onclick = () => {
  const inp = document.getElementById('chatInput'); const v = inp.value.trim();
  if (!v) return; addChatMsg(v, true); api.sendMessage('temp', v); inp.value='';
};
document.querySelectorAll('input[name="locmode"]').forEach(r => r.onchange = toggleLocOptions);
document.getElementById('pinPick').onclick  = () => startPickPin();
document.getElementById('pinSave').onclick  = () => {
  const lat = parseFloat(document.getElementById('pinLat').value);
  const lng = parseFloat(document.getElementById('pinLng').value);
  if (Number.isFinite(lat) && Number.isFinite(lng)) { state.pinned = {lat,lng}; toast('Pin saved'); }
  else toast('Enter valid lat and lng');
};

/* Boot */
initMap();
restore();
openCard();         // first-run
toggleLocOptions(); // ensure correct sub options visibility

/* After saving card, location mode will load riders. For dev, if user closes card without saving, nothing loads yet. */

/* Minimal console tests */
(function tests(){
  const log = (ok, name, err) => ok ? console.log('✅', name) : console.error('❌', name, err||'');
  try { const c = state.map.getCenter(); if (!Number.isFinite(c.lat)) throw 'no center'; log(true,'Map has initial center'); } catch(e){ log(false,'Map has initial center', e); }
  try { document.getElementById('riderCardBtn'); log(true,'Rider Card button present'); } catch(e){ log(false,'Rider Card button present', e); }
})();
</script>
</body>
</html>
